# Bonus: What Happens??

在算術運算中，C11規定如果兩邊操作數(Operand)不同，則會先作類型轉(Usual Arithmetic Conversion)換才做運算。

## r1的計算

在運算`r1`時，`ui`和`si`都是32位元的 int，唯`ui`是無符號數，`si`是有符號數。根據規則，如果*無符號數的 rank 不低於有符號數*，則將**有符號數**轉成另一邊的**無符號數**類型。

因此，`si`在計算時轉換成無符號數後，從 -1 變成對應的有符號數 2^32 - 1，即 4294967295（以gcc compiler爲例）；`ui`則保持一樣。計算
```c
r1 = ui + si;
```
的結果便是 0 + 4294967295 = 4294967295。

## r2的計算

在運算`r2`時，`us`是無符號16位元的 int，`si`是有符號32位元的int。由於`us`的 rank 小於`si`，因此計算`r1`時的轉換規則不適用。但從之後的規則可知，如果*有符號數可表示所有無符號數的數值範圍*，則將**無符號數**轉成另一邊的**有符號數**類型。

因此，`us`和`si`在計算時轉換成有符號32位元後，仍然保持同樣的數值。計算
```c
r2 = us + si;
```
的結果便是 0 + (-1) = -1。

## r1，r2的賦值

計算`r1`和`r2`後，在賦值前會將等號右邊的類型轉換成左邊的類型再做賦值。由於兩者計算結果都在有符號64位元的 int 的範圍內，因此賦的值和計算結果一致。