# Bonus: `_BitInt(n)`

`_BitInt(n)` is a new integer types, presented in C23, which is bit-precise signed integer type. The `n` is an integer constant, where it specifies the number of bits that are used to represent the type, including the sign bit.

## `sizeof(_BitInt(n))`

`sizeof(_BitInt(n))` will give the following result:

- If `2 <= n <= 8`, then it's size is 1.
- If `9 <= n <= 16`, then it's size is 2.
- If `17 <= n <= 32`, then it's size is 4.
- If `33 <= n <= 64`, then it's size is 8.
- If `65 <= n <= 128`, then it's size is 16.

## Value Assign

If a value larger than the given size is assigned, a warning of implicit conversion will occur and the value will be converted.

Example:

```c
_BitInt(5) x = 16;
_BitInt(4) y = 16;
```

Since `16` is `10000` in binary form which exceeds the range `[-16, 15]`, then `x` will be stored as `-16`, where the MSB is used to represent sign of value.

As `y` only stores 4 bits, therefore it only stores lowest 4 bits of `10000`, which is `0000`. Hence it converts to `0`.

## Arithmetic Operations

Arithmetic operations are allowed with 2 different bits. The lower bit will first convert to higher bit, then the operation will be processed. The result type will be the higher bit.

Example:

```c
_BitInt(3) a = 1;
_BitInt(4) b = 3;

int32_t c = a + b;
```

`a + b` will convert `a` to `_BitInt(4)` and then the addition follows, which results in `4` in type of `_BitInt(4)`.

## Signed and Unsigned `_BitInt`

If arithmetic operations are operated between `unsigned _BitInt(n)` and `_BitInt(n)`, then the result will be `unsigned _BitInt(n)`.

```c
_BitInt(5) p = 7;
_BitInt(5) q = 15;
unsigned _BitInt(5) r = 15;

int32_t res1 = p + q;
int32_t res2 = p + r;
```

Since `p` and `q` are signed values, and the range of 5 bits integer are `[-16, 15]`, the result of `p + q` is `111 + 1111 = 10110` which overflows to `-10` in 5 bits integer. Hence the value of `res1` is `-10`.

As `r` is unsigned value, `p + r` will first convert `p` to unsigned integer. Then `111 + 1111 = 10110` will be remained as `22`, which is still in the range of unsigned 5 bits integer `[0, 31]`. Hence the value of `res2` is `22`.

## `BITINT_MAXWIDTH`

If `n` is greater than `BITINT_MAXWIDTH`, an error will occur. The `BITINT_MAXWIDTH` has same value as `ULLONG_WIDTH`, which is defined in `limits.h`.

Besides, the minimum of size of `_BitInt(n)` is 2 as it requires a bit to store the sign of value, while `unsigned _BitInt(n)` requires at least 1 bit.
